require "modules.common"

-------------------------------------------------------------------------------------------------
----------------------------- Player animation finite state machine -----------------------------
local moduleFsm = require "modules.fsm"
local fsm = moduleFsm.create({
	initial = "idle",
	events = { -- TODO: event/state naming convention
		{ name = "startrun", 		from = "idle", 								to = "running"		},
		{ name = "stoprun",  		from = "running", 							to = "idle" 		},
		{ name = "attack", 			from = { "idle", "running", "attacking" },	to = "attacking"	},
		{ name = "attackfinished",	from = { "attacking" },						to = "idle" 		},
		{ name = "fall", 			from = { "idle", "running", "attacking" }, 	to = "falling"		},
		{ name = "damaged", 		from = "*", 								to = "hurt"			},
		{ name = "death", 			from = "*", 								to = "dead" 		},
		{ name = "stopfall", 		from = "falling", 							to = "idle" 		},
		{ name = "toidle",	 		from = "*", 								to = "idle" 		}
	},
})

-- fsm extension --
fsm.blackboard					= {}
fsm.blackboard[param_move]		= 0
fsm.blackboard[tag_grounded]	= false
fsm.blackboard[tag_attack]		= false
fsm.blackboard[tag_hurt]		= false

-- on enter state idle
function fsm:onidle(event, from, to)
	msg.post("#sprite", "play_animation", { id = hash("idle") })
end

function fsm:onupdateidle(dt)
	local b = self.blackboard
	if b[tag_hurt] then
		self:damaged()
	elseif not b[tag_grounded] then
		self:fall()
	elseif b[param_move] ~= 0 then
		self:startrun()
	end
end

-- on enter state running
function fsm:onrunning(event, from, to)
	msg.post("#sprite", "play_animation", { id = hash("run") })
end

function fsm:onupdaterunning(dt)
	local b = self.blackboard
	if b[tag_hurt] then
		self:damaged()
	elseif not b[tag_grounded] then
		self:fall()
	elseif b[param_move] == 0 then
		self:stoprun()
	end
end

-- TODO: temporary implementation, attack MUST be refactored
-- on enter state attack1
local attack_num = 1
local attack_request = false
local attack_anim_in_progress = false

function fsm:onattacking(event, from, to)
	local attackAnim = hash("attack" .. attack_num)
	msg.post("#sprite", "play_animation", { id = attackAnim })
	msg.post(".", msgtype_tag, { id = tag_attack, value = true })
	attack_request = false
	attack_anim_in_progress = true
	attack_num = math.fmod(attack_num, 3) + 1
end

function fsm:onbeforeattack(event, from, to)
	if attack_anim_in_progress then
		attack_request = true
		return false
	end

	return true
end

function fsm:onattackfinished(event, from, to)
	msg.post(".", msgtype_tag, { id = tag_attack, value = false })
end

function fsm:onmessageattacking(message_id, message, sender)
	if message_id == hash("animation_done") then
		attack_anim_in_progress = false
		if attack_request == true then
			self:attack()
		else
			self:attackfinished()
		end
	end
end

-- on enter state falling
function fsm:onfalling(event, from, to)
	msg.post("#sprite", "play_animation", { id = hash("fall") })
end

function fsm:onupdatefalling(dt)
	local b = self.blackboard
	if b[tag_hurt] then
		self:damaged()
	elseif b[tag_grounded] then
		self:stopfall()
	end
end

-- on enter state hurt
function fsm:onhurt(event, from, to)
	msg.post("#sprite", "play_animation", { id = hash("hurt") })
	msg.post(".", msgtype_tag, { id = tag_hurt, value = true })
end

function fsm:onmessagehurt(message_id, message, sender)
	if message_id == hash("animation_done") then
		msg.post(".", msgtype_tag, { id = tag_hurt, value = false })
		fsm:toidle()
	end
end

-- on enter state dead
function fsm:ondead(event, from, to)
	msg.post("#sprite", "play_animation", { id = hash("die") })
end

-- For debug purpose --
function fsm:onstatechange(event, from, to) 
	print("[PlayerAnimFsm] event: " .. event .. ", transition: " .. from .. " --> " .. to) 
end

----------------------------------------------
-- fsm extension 							--
-- can be added into module					--
----------------------------------------------
function fsm:update(dt)
	local updatehandlername = "onupdate" .. self.current
	if self[updatehandlername] ~= nil then
		self[updatehandlername](self, dt)
	end
	if self.blackboard[param_move] ~= 0 then
		sprite.set_hflip("#sprite", self.blackboard[param_move] < 0)
	end
end

function fsm:on_message(message_id, message, sender)
	if message_id == msgtype_param or message_id == msgtype_tag then
		if self.blackboard[message.id] ~= nil then		-- to avoid blackboard polution
			assert(message.value ~= nil)
			self.blackboard[message.id] = message.value
		end
	else
		if message_id == msgtype_trigger then
			if message.id == trigger_attack then
				self:attack()
			elseif message.id == trigger_damage then
				self:damaged()
			end
		end
		local messagehandler = "onmessage" .. self.current
		if self[messagehandler] ~= nil then
			self[messagehandler](self, message_id, message, sender)
		end
	end
end
---------------------------------------------------------------

---------------------------------------------------------------
--						ANIM CONTROLLER						 --
-- Just wrapper over fsm, is fsm class realy needed?		 --
---------------------------------------------------------------

function update(self, dt)
	fsm:update(dt)
end

function on_message(self, message_id, message, sender)
	fsm:on_message(message_id, message, sender)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
